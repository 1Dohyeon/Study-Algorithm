[[오토마타 알고리즘]] 을 이용한 매칭 방법과 비슷하다. 매칭에 실패했을 때 돌아갈 상태를  π 배열 담는다. 이때 원래 들어와야 하는 알파벳이 들어왔다고 가정하고 앞에 중복되는 것이 있나 살펴 본 후 이동한다.

### KMP 알고리즘 예시
- `ababaca` 라는 문자열을 찾는다고 가정.
- `P[] = [a, b, a, b, a, c, a]`
- `π[]` <- 매칭에 실패했을 때 돌아갈 곳에 대한 상태를 저장
- ex) `banana`에서 앞에 `ana`는 접두사, 뒤에 `ana`는 접미사. 접두사의 꼬리와 접미사의 머리 `a`는 공유된다. 이를 설명하는 이유로는, 접두사와 접미사의 크기로 돌아갈 수 있는 상태를 판단하기 때문이다.
- 오토마타에서는 돌아갈 곳이 없다면 `0`상태로 돌아가지만, KMP 알고리즘에서는 돌아가야 할 경우 `접두사+1` 칸으로 돌아간다. 보통은 `접두사` 크기만큼만 움직이면 되지만, 책마다 기준이 전부 다르다. 설명이 어려움으로 아래 예시에서 자세히 설명.

- `ababaca` 순서대로 `π`의 상태
1) `a`, `m=1`
    -  이때의 상태는 `1`로 가야한다.
    - `π`에는 매칭 실패시 이동할 상태를 저장하기 때문에 π의 첫번째 칸은 상태 처음 상태 `0`의 값을 가진다.(인덱스는 0부터지만 보기 편하게 1로 가정)
    - `π[1] = 0`
2) `b`, `m=2`
    - `ab` 상태`k`는 `2`를 가진다.
    - `b`를 찾지 못했기에 `π`는 `a`만 있는 상태로 돌아가야 한다.
    - `π[2] = 1(접두사(0) + 1)`
3) `a`, `m=3`
    - `aba` 상태는 `3`
    - `a`를 찾지 못한 경우 `ab`의 상태에서 돌아갈 방법을 찾아야한다. 접두사와 접미사가 딱히 존재하지 않으니 처음 `a`만 있던 상태인 `1`로 돌아간다.
    - `π[3] = 1(접두사(0) + 1)`
4) `b`, `m=4`
    - `abab` 상태는 `4`
    - `b`를 찾지 못했을 경우 `aba`에서 `b`를 기준으로 접두사 `a`, 접미사 `b`를 찾을 수 있다.
    - `π[4] = 2(접두사(1) + 1)`
5) `a`, `m=5`
    - `ababa` 상태는 `5`
    - `a`를 찾지 못했을 경우 `abab`에서 접두사는 앞의`ab`, 접미사는 뒤의 `ab`이다.
    - 따라서 `π[5] = 3(접두사(2) + 1)`
6) `c`, `m=6`
    - `ababac` 상태는 `6`
    - `c`를 찾지 못한 경우인 `ababa`에서 중간 `a`를 공유하는 접두사 `aba`, 접미사 `aba`가 있음을 알 수 있다.
    - `π[6] = 4(접두사(3) + 1)`
7) `a`, `m=7`
    - `ababaca` 상태는 `7`
    - `a`를 찾지 못한 경우인 `ababac`에서 접두사와 접미사를 찾을 수 없다.(간혹 앞에 `ababa`에서 찾으면 안되냐고 하는데, 맨뒤 알파벳이 꼭 포함 되어야한다. 따라서 `c`는 뒤에서만 찾을 수 있고, 앞에서는 못찾기 때문에 접두사와 접미사는 없다.)
    - `π[7] = 1(접두사(0) + 1)`
    - **원하는 문자열을 찾았기 때문에 찾았음을 알린다.**
8) `m+1`
    - 다음 알파벳을 찾지 못한 경우인 `ababaca`에서 첫`a`와 끝`a`가 접두사 접미사이다.
    - `π[8(m+1)] = 2(접두사(1) + 1)`

최종적으로 `π[] = [0, 1, 1, 2, 3, 4, 1, 2]`

돌아갈 곳에 대한 정보 π를 설정하는 수도 코드는 아래와 같다.
```
preprocessing(P[ ]) {
	j ←1;
	k ←0; 
    π[1] ← 0;
	
    while (j ≤ m) {
		if (k = 0 or P[j] = P[k]) then { j++; k++; π[j] ← k; } 
        else k ← π[k];
	}
}
```

---
### KMP 알고리즘의 수도코드
```
KMP(A[ ], P[ ]) {	// n: 배열 A의 길이, m: 배열 P의 길이
	preprocessing(P); 	// 수행시간 Θ(m)
    i ←1; 				// 본문 문자열 포인터
	j ←1; 				// 패턴 문자열 포인터
	
    while (i ≤ n) {
		if (j = 0 or A[i] = P[j]) then { 
        	i++; j++; 
        } else j ← π[j];
        if (j = m+1) then {
			A[i-m]에서 매칭이 일어났음을 알린다;
			j ← π[j];
        }
	}
}
```
수행시간 : `Θ(n)`