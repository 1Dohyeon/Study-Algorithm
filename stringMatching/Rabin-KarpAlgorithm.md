### 수치화 후 문자열 매칭 알고리즘
이 알고리즘은 문자열 패턴을 숫자로 바꾸어서 문자열 비교를 수치화를 통해 비교한다. 예를 들어 a, b, c, d가 있을 경우 각각 0, 1, 2, 3으로 수치화를 한다.

하지만 이 방법에도 문제점이 있다. 수치화 작업이 부담되기도 하고, 수치가 커져서 오버플로우가 발생 할 수도 있다. 이 두가지 문제점을 해결하며 문자열 매칭을 수행하는 것이 중요하다.

---
### 수치화 작업
A[i ... i+m-1]에 대응되는 수치의 계산(ex. "eeaab")
- 알파벳이 5개이므로 `d(진수) = 5`
- p(수치화된 문자열) = 4x5^4  + 4x5^3 + 0x5^2 + 0x5^1 + 1x5^0 => `p = 3001`
> p = ∑ 수치화된 알파벳 x d^m               (m= (d-i) (i=1 to d))

이제 A[] 가 `acebeeaabadcce` 일 경우 p를 구한 공식대로 `a1 = acebe, a2 = cebee, ... `한 칸씩 밀려가며 각 알파벳을 수치화한다. 수치화 후 p와 일치하면 문자열을 찾은 것이다.

하지만 이렇게 하나하나 수치화를 한다면 시간복잡도는 `Θ(mn)`로, [[원시적인 매칭(Nativa Matching)]]보다 나은게 없다. 하지만 이 문제는 바로 해결할 수 있다.

`acebeeaabadcce` 에서 `a1 = 0x5^4  + 2x5^3 + 4x5^2 + 1x5^1 + 4x5^0` 임을 알 수 있다.
또한 `a2 = 2x5^4 + 4x5^3 + 1x5^2+ 4x5^1 + 4x5^0` 임을 알 수 있다. 여기서 공통된 점을 발견할 수 있다. `a1`의 첫번째 요소인 `2x5^4`를 빼고 `d`만큼을 곱한다. 그 후에 `a2`의 마지막 요소만 더한다면 `a2` 전체 식이 나오게 된다. 이로써 수행시간을 단축시킬 수 있다.
- ai의 마지막 요소 = c
> ai = d(ai-1 - (d^m-1)xA[i-1]) + c

---
### 수도 코드
```
basicRabinKarp(A, P, d) {		// n : 배열 A의 길이, m : 배열 P의 길이 
	p ← 0; a1 ← 0; 
    for i←1 to m {				// 패턴P의 수치값 p와 a1 계산
		p ← dp + P[i];
		a1 ← da1 + A[i]; 
    }
	if (p = a1) then A[1] 자리에서 매칭이 일어났음을 알린다; 
    for i ← 2 to n-m+1	{
		ai ← d(ai-1 ? dm-1A[i-1]) + A[i+m-1];
		if (p = ai) then A[i] 자리에서 매칭이 일어났음을 알린다; 
    }
}
```
수행 시간은 `Θ(n)`시간으로 `Θ(mn)`보다 줄어들었다. 하지만 이것은 **라빈-카프(Rabin-Karp) 알고리즘이 아니다.**

아직 위 알고리즘에서는 문자 집합 크기`d`와 패턴의 길이 `m`에 따라 `ai`가 매우 커질 수 있다는 문제점을 가지고 있다. 따라서 레지스터의 용량 초과로 오버플로우가 발생될 가능성이 있다.

---
### 라빈-카프(Rabin-Karp) 알고리즘

**나머지 연산(modulo)** 을 통해서 `ai`의 크기를 제한할 수 있다.
기존 식인 `ai = d(ai-1 ? (d^m-1)xA[i-1]) + A[i+m-1] `대신에 `bi = (d(bi-1 ? ((d^m-1) mod q)xA[i-1]) + A[i+m-1]) mod q` 사용한다.  이때 `q`를 충분히 큰 소수(prime number)로 정한다.

**나머지 연산을 이용한 매칭 수도 코드**
```
RabinKarp(A,P,d,q) {		// n:배열A의길이, m:배열P의길이 {
	h ← 1;
	for i ← 1 to m-1
		h ← dh mod q;		// h 계산(= dm-1 mod q)
	p ← 0; b1 ← 0; 
    for i ← 1 to m {
		p ← (dp + P[i]) mod q; 		// 패턴 P의 수치값 p 계산
        b1 ← (db1 + A[i]) mod q;	// b1 계산
	}
	for i ← 1 to n-m+1{
		if (i ≠ 1) then bi ← (d(bi-1 ? hA[i-1]) + A[i+m-1]) mod q; 
        if (p = bi) then
			if (P[1...m] = A[i...i+m-1]) then // 진짜 매칭인지 알아봄 
            	A[i] 자리에서 매칭이 일어났음을 알린다;
}
```
수행시간 : 매칭 횟수가 상수 번이면 `Θ(n)`. 즉, 평균 수행시간 = `Θ(n)`
최악의 경우 : `Θ(mn)` (모든 문자가 동일한 경우)