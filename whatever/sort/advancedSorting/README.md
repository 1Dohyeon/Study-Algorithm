# 1. 힙 정렬(Heap Sort) 알고리즘

힙 정렬 알고리즘은 이진 힙(Binary Heap) 자료 구조를 활용하여 배열을 정렬하는 알고리즘입니다. 아래는 주어진 Java 코드에서 사용된 힙 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열을 힙으로 변환합니다. 힙은 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 구성할 수 있으며, 여기서는 최대 힙을 기준으로 설명합니다.

2. 힙에서는 루트 노드가 항상 최대값(또는 최소값)을 가지므로, 최대값을 배열의 맨 끝으로 이동합니다.

3. 배열의 크기를 줄이고, 변경된 배열을 다시 힙 조건을 만족하도록 재구성합니다.

4. 위 과정을 반복하여 배열이 정렬됩니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 힙 정렬하는 과정입니다.

1. 처음 배열: `{5, 2, 9, 3, 4, 6}`

2. 배열을 최대 힙으로 변환:
    - `{9, 5, 6, 3, 4, 2}`

3. 최대값 `9`를 배열의 맨 끝으로 이동:
    - `{2, 5, 6, 3, 4, 9}`

4. 배열 크기를 줄이고 다시 최대 힙으로 변환:
    - `{6, 5, 2, 3, 4}`

5. 최대값 `6`을 배열의 맨 끝으로 이동:
    - `{4, 5, 2, 3, 6}`

6. 배열 크기를 줄이고 다시 최대 힙으로 변환:
    - `{5, 4, 2, 3}`

7. 최대값 `5`를 배열의 맨 끝으로 이동:
    - `{3, 4, 2, 5}`

8. 배열 크기를 줄이고 다시 최대 힙으로 변환:
    - `{4, 3, 2}`

9. 최대값 `4`를 배열의 맨 끝으로 이동:
    - `{2, 3, 4}`

10. 배열 크기를 줄이고 다시 최대 힙으로 변환:
    - `{3, 2}`

11. 최대값 `3`을 배열의 맨 끝으로 이동:
    - `{2, 3}`

12. 배열 크기를 줄이고 다시 최대 힙으로 변환:
    - `{2}`

13. 최대값 `2`를 배열의 맨 끝으로 이동:
    - `{2}`

14. 배열의 크기가 1이므로 정렬이 완료됩니다.

이렇게 반복해서 배열이 정렬됩니다.

힙 정렬은 안정적인 정렬 알고리즘 중 하나이며, 최악, 평균, 최선의 시간 복잡도가 O(n log n)으로 매우 효율적입니다.

---
# 2. 병합 정렬(Merge Sort) 알고리즘

병합 정렬 알고리즘은 분할 정복(Divide and Conquer) 방법을 사용하여 배열을 정렬하는 알고리즘으로, 배열을 절반으로 나눈 뒤 각각을 정렬하고 다시 병합하여 정렬된 배열을 생성합니다. 아래는 주어진 Java 코드에서 사용된 병합 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열을 반으로 나눕니다.

2. 각각의 반쪽 배열에 대해 재귀적으로 병합 정렬을 호출합니다. 배열의 크기가 1이 될 때까지 분할하고 정렬합니다.

3. 두 개의 정렬된 반쪽 배열을 병합하여 하나의 정렬된 배열로 만듭니다. 이 과정에서 작은 원소부터 차례대로 병합합니다.

4. 위 과정을 반복하여 배열이 정렬됩니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 병합 정렬하는 과정입니다.

1. 처음 배열: `{5, 2, 9, 3, 4, 6}`

2. 배열을 반으로 나누고 재귀적으로 정렬:
    - 왼쪽 배열: `{5, 2, 9}`
    - 오른쪽 배열: `{3, 4, 6}`

3. 왼쪽 배열을 다시 반으로 나누고 재귀적으로 정렬:
    - 왼쪽 배열: `{5}`
    - 오른쪽 배열: `{2, 9}`

4. 왼쪽 배열과 오른쪽 배열을 병합하여 `{2, 5, 9}`로 정렬.

5. 오른쪽 배열을 다시 반으로 나누고 재귀적으로 정렬:
    - 왼쪽 배열: `{3}`
    - 오른쪽 배열: `{4, 6}`

6. 왼쪽 배열과 오른쪽 배열을 병합하여 `{3, 4, 6}`로 정렬.

7. 최종적으로 `{2, 3, 4, 5, 6, 9}`로 정렬됩니다.

병합 정렬은 안정적인 정렬 알고리즘 중 하나이며, 항상 O(n log n)의 시간 복잡도를 가지므로 대규모 데이터셋에서도 효율적으로 동작합니다.

---
# 3. 퀵 정렬(Quick Sort) 알고리즘

퀵 정렬 알고리즘은 분할 정복(Divide and Conquer) 방법을 사용하여 배열을 정렬하는 알고리즘으로, 특정한 원소를 피벗(pivot)으로 선택하고 피벗을 기준으로 배열을 분할하며 정렬합니다. 아래는 주어진 Java 코드에서 사용된 퀵 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열을 피벗을 기준으로 두 개의 부분 배열로 분할합니다. 피벗보다 작은 원소는 왼쪽 부분 배열에, 큰 원소는 오른쪽 부분 배열에 위치하도록 합니다.

2. 분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 호출합니다. 각 부분 배열에서도 피벗을 기준으로 다시 분할하고 정렬합니다.

3. 재귀 호출이 종료되면 배열이 정렬됩니다. 분할과정에서 정렬이 이루어지므로 전체 배열이 정렬됩니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 퀵 정렬하는 과정입니다.

1. 처음 배열: `{5, 2, 9, 3, 4, 6}`

2. 피벗 선택: 예를 들어 배열의 마지막 원소 `6`을 피벗으로 선택합니다.

3. 피벗을 기준으로 배열을 분할:
    - 왼쪽 부분 배열: `{2, 3, 4, 5}`
    - 오른쪽 부분 배열: `{9, 6}`

4. 왼쪽 부분 배열을 재귀적으로 정렬:
    - 피벗 선택: 예를 들어 배열의 마지막 원소 `5`를 피벗으로 선택합니다.
    - 피벗을 기준으로 배열을 분할:
        - 왼쪽 부분 배열: `{2, 3, 4}`
        - 오른쪽 부분 배열: `{}` (비어있음)
    - 배열 `{2, 3, 4}`는 이미 정렬되어 있으므로 변화 없음.

5. 오른쪽 부분 배열을 재귀적으로 정렬:
    - 피벗 선택: 예를 들어 배열의 마지막 원소 `6`을 피벗으로 선택합니다.
    - 피벗을 기준으로 배열을 분할:
        - 왼쪽 부분 배열: `{}` (비어있음)
        - 오른쪽 부분 배열: `{9}`
    - 배열 `{9}`는 이미 정렬되어 있으므로 변화 없음.

6. 최종적으로 `{2, 3, 4, 5, 6, 9}`로 정렬됩니다.

퀵 정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지며, 빠른 정렬 알고리즘 중 하나입니다. 다만 최악의 경우 시간 복잡도가 O(n^2)가 될 수 있으므로 피벗 선택에 주의해야 합니다.
