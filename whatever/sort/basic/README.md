# 1. 버블 정렬(Bubble Sort) 알고리즘

버블 정렬 알고리즘은 간단한 정렬 알고리즘으로, 인접한 두 원소를 비교하면서 정렬 순서가 아니면 위치를 교환하는 방식으로 정렬합니다. 아래는 주어진 Java 코드에서 사용된 버블 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열의 길이를 구합니다. 이를 변수 `n`에 저장합니다.

2. 바깥쪽 반복문을 통해 정렬을 반복합니다. 바깥쪽 반복문은 배열의 길이보다 하나 작은 횟수만큼 반복됩니다. (마지막 원소는 자동으로 정렬되기 때문입니다)

3. 내부 반복문을 통해 배열의 원소를 비교하고 필요한 경우 교환합니다. 내부 반복문은 현재 정렬 중인 부분에서 가장 큰 원소를 배열의 끝으로 옮기는 역할을 합니다.

4. 만약 내부 반복문에서 어떤 원소도 교환하지 않았다면, 배열은 이미 정렬된 상태이므로 정렬 과정을 종료합니다.

5. 위 과정을 반복하면서 배열을 정렬합니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 버블 정렬하는 과정입니다.

1. 첫 번째 패스:
    - `2`와 `5`를 비교하여 교환: `{2, 5, 9, 3, 4, 6}`
    - `5`와 `9`를 비교하여 교환: `{2, 5, 9, 3, 4, 6}`
    - `9`와 `3`을 비교하여 교환: `{2, 5, 3, 9, 4, 6}`
    - `9`와 `4`를 비교하여 교환: `{2, 5, 3, 4, 9, 6}`
    - `9`와 `6`을 비교하여 교환: `{2, 5, 3, 4, 6, 9}`
    - 이 패스에서 교환이 발생했으므로 아직 정렬이 완료되지 않았습니다.

2. 두 번째 패스:
    - `2`와 `5`를 비교하여 교환: `{2, 5, 3, 4, 6, 9}`
    - `5`와 `3`을 비교하여 교환: `{2, 3, 5, 4, 6, 9}`
    - `5`와 `4`를 비교하여 교환: `{2, 3, 4, 5, 6, 9}`
    - 이 패스에서 교환이 발생했으므로 아직 정렬이 완료되지 않았습니다.

3. 세 번째 패스:
    - `2`와 `3`을 비교하여 교환: `{2, 3, 4, 5, 6, 9}`
    - 이 패스에서 교환이 발생했으므로 아직 정렬이 완료되지 않았습니다.

4. 네 번째 패스:
    - `2`와 `3`을 비교하여 교환: `{2, 3, 4, 5, 6, 9}`
    - 교환이 발생하지 않았으므로 정렬이 완료되었습니다.

5. 최종 정렬된 배열: `{2, 3, 4, 5, 6, 9}`

이렇게 반복해서 패스를 수행하며 가장 큰 원소가 맨 뒤로 이동하면서 배열이 정렬됩니다.

버블 정렬은 간단하지만 비효율적인 알고리즘으로, 대규모 데이터셋에서는 다른 정렬 알고리즘을 고려하는 것이 좋습니다.

---
# 2. 삽입 정렬(Insertion Sort) 알고리즘

삽입 정렬 알고리즘은 배열을 정렬하는 간단한 알고리즘으로, 정렬된 부분과 정렬되지 않은 부분을 나누고 정렬되지 않은 부분에서 하나씩 원소를 선택하여 정렬된 부분에 삽입하는 방식으로 동작합니다. 아래는 주어진 Java 코드에서 사용된 삽입 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열의 길이를 구합니다. 이를 변수 `n`에 저장합니다.

2. 바깥쪽 반복문을 통해 정렬을 반복합니다. 바깥쪽 반복문은 두 번째 원소부터 시작하여 배열의 끝까지 순회합니다.

3. 내부 반복문을 통해 현재 선택한 원소(`key`)를 적절한 위치에 삽입합니다. 내부 반복문은 `key`보다 큰 원소를 찾을 때까지 이동하면서 원소를 오른쪽으로 이동시킵니다.

4. 내부 반복문이 종료되면 `key`를 적절한 위치에 삽입합니다. 이를 통해 정렬된 부분이 하나 더 커지게 됩니다.

5. 위 과정을 반복하면서 배열이 정렬됩니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 삽입 정렬하는 과정입니다.

1. 처음 배열: `{5, 2, 9, 3, 4, 6}`
2. 두 번째 원소 `2`를 선택하여 적절한 위치로 삽입하면 배열은 `{2, 5, 9, 3, 4, 6}`가 됩니다.
3. 세 번째 원소 `9`를 선택하여 적절한 위치로 삽입하면 배열은 `{2, 5, 9, 3, 4, 6}`에서 변화가 없습니다.
4. 네 번째 원소 `3`을 선택하여 적절한 위치로 삽입하면 배열은 `{2, 3, 5, 9, 4, 6}`이 됩니다.
5. 다섯 번째 원소 `4`를 선택하여 적절한 위치로 삽입하면 배열은 `{2, 3, 4, 5, 9, 6}`이 됩니다.
6. 여섯 번째 원소 `6`을 선택

---
# 3. 선택 정렬(Selection Sort) 알고리즘

선택 정렬 알고리즘은 배열을 정렬하는 간단한 알고리즘으로, 정렬되지 않은 부분에서 가장 작은 원소를 선택하여 정렬된 부분의 끝에 추가하는 방식으로 동작합니다. 아래는 주어진 Java 코드에서 사용된 선택 정렬 알고리즘의 원리입니다.

## 알고리즘 원리

1. 주어진 배열의 길이를 구합니다. 이를 변수 `n`에 저장합니다.

2. 바깥쪽 반복문을 통해 정렬을 반복합니다. 바깥쪽 반복문은 배열의 첫 번째 원소부터 배열의 끝에서 두 번째 원소까지 순회합니다.

3. 내부 반복문을 통해 현재 위치부터 배열의 끝까지 원소를 비교하여 가장 작은 원소의 인덱스(`minIndex`)를 찾습니다.

4. `minIndex`와 현재 위치의 원소를 교환합니다. 이를 통해 정렬된 부분의 끝에 최솟값이 추가됩니다.

5. 위 과정을 반복하면서 배열이 정렬됩니다.

## 예제

다음은 주어진 배열 `{5, 2, 9, 3, 4, 6}`을 선택 정렬하는 과정입니다.

1. 처음 배열: `{5, 2, 9, 3, 4, 6}`
2. 첫 번째 원소 `2`를 선택하여 최솟값으로 설정하고, 나머지 원소와 비교하여 가장 작은 값인 `2`를 현재 위치로 옮깁니다. 배열은 `{2, 5, 9, 3, 4, 6}`이 됩니다.
3. 두 번째 원소 `3`을 선택하여 최솟값으로 설정하고, 나머지 원소와 비교하여 가장 작은 값인 `3`을 현재 위치로 옮깁니다. 배열은 `{2, 3, 9, 5, 4, 6}`이 됩니다.
4. 세 번째 원소 `4`를 선택하여 최솟값으로 설정하고, 나머지 원소와 비교하여 가장 작은 값인 `4`을 현재 위치로 옮깁니다. 배열은 `{2, 3, 4, 9, 5, 6}`이 됩니다.
5. 네 번째 원소 `5`를 선택하여 최솟값으로 설정하고, 나머지 원소와 비교하여 가장 작은 값인 `5`를 현재 위치로 옮깁니다. 배열은 `{2, 3, 4, 5, 9, 6}`이 됩니다.
6. 다섯 번째 원소 `6`을 선택하여 최솟값으로 설정하고, 나머지 원소와 비교하여 가장 작은 값인 `6`을 현재 위치로 옮깁니다. 배열은 `{2, 3, 4, 5, 6, 9}`이 됩니다.

이렇게 반복해서 배열이 정렬됩니다.

선택 정렬은 간단하고 이해하기 쉬운 알고리즘이지만, 대규모 데이터셋에서는 다른 정렬 알고리즘(예: 병합 정렬, 퀵 정렬)을 고려하는 것이 좋습니다.



