### 6.1 Greedy (그리디 알고리즘)

그리디 알고리즘의 "그리디(Greedy)" 는 직역하면 "탐욕", "욕심" 이라는 뜻을 가지고 있다. 이 의미 그대로 그리디 알고리즘은 이전 이후를 고려하지 않고 당장 현재 상태에서 최적의 해를 찾는 알고리즘이다.

[프림Prim 알고리즘](https://github.com/1Dohyeon/Study-Algorithms/blob/main/Graph.md)으로 예를 들자면 이 알고리즘은 간단하게 설명하면 간선간에 가중치가 있는 그래프에서 최소 신장의 트리를 찾기 위한 알고리즘이다.

**수도 코드**

```
Prim ( G, r)
{
	S ← Ф ; 정점 r을 방문되었다고 표시하고, 집합 S에 포함시킨다;
	while ( S≠ V) {
		S에서 V- S를 연결하는 간선들 중 최소길이의 간선 ( x, y)를 찾는다; ▷ ( x∈ S, y∈ V-S)
		정점 y를 방문되었다고 표시하고, 집합 S에 포함시킨다;
	}
}
```

위 수도 코드에서 `S에서 V- S를 연결하는 간선들 중 최소길이의 간선 ( x, y)를 찾는다;` 이 부분이 그리디한 부분이다. 현재 상황에서 최소 길이를 찾기 때문이다.

이렇게 그리디 알고리즘을 적용해야하는 문제는 보통 현재 최적의 해를 찾고 이 알고리즘을 반복하는 행위를 한다.

### 6.2 회의실 배정

회의실 배정 문제는 그리디 알고리즘 예제 문제 중 대표적인 문제이다. 여기서는 백준: 회의실 배정](https://www.acmicpc.net/problem/1931) 문제의 풀이과정을 다룬다.

**문제**
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

**입력**
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

**출력**
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

**예제 입력**

```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

**예제 출력**

```
4
```

위 문제를 보면 회의실 이용시간이 긴 회의는 안고르는게 좋다고 생각이 들거다.
또한 가장 짧은 회의순을 우선으로 둬야겠다고 생각할 수도 있다.

하지만 이는 좋은 접근법이 아니다. 회의중인 회의실이 있을 때, 그 이후에 많은 회의를 할 수 있게 하려면 어떻게 해야할까?

바로 지금 회의중인 회의를 빨리 끝내야 한다. 즉, 종료 시간이 가장 이른 것이 그리디한 요소이다. 그 이후에 생각해야 할 요소는 종료시간이 같은 경우이다. `[5, 5]`와 `[4, 5]`가 있을 때 `[4, 5]`를 택하고, 그 다음으로 `[5, 5]`도 회의를 할 수 있다.

파이썬을 통해서 위 알고리즘을 아래와 같이 설계하였다.

```python
def solution(arr): # [[1,2], [3,4], ...] 형태의 2차원 배열로 입력받음.
    cnt = 1
    arr.sort(key = lambda x: x[0])
    arr.sort(key = lambda x: x[1])

    end = room[0][1]
    for i in range(1, n):
        if room[i][0] >= end:
            cnt += 1
            end = room[i][1]
           
    return cnt

# 입출력
n = int(input()) # 회의실을 사용하려는 회의의 갯수
room = []        # 회의 시간을 담을 2차원 배열

for i in range(n):
    a, b = map(int, input().split())
    room.append([a, b])

print(solution(room))
```

위 코드를 봐보면 우선 `arr.sort(key = lambda x: x[0])` 후에 `arr.sort(key = lambda x: x[1])`를 실행한 것을 알 수 있다.

끝시간이 우선이지만 시작 시간을 기준으로 먼저 정렬하였다. 위에서 설명했듯이 끝나는 시간이 동일할 경우 시작하는 시간을 먼저 앞세우기 위함이다.

첫번째 끝 시간은 당연히 `end[0][1]`로 설정한다. 그 후 반복문을 통해서 모든 회의실 갯수를 한번씩만 탐색한다.

반복문을 실행하면서 이 다음 회의의 시작시간이 지금 회의 중인 회의의 끝나는 시간보다 같거나 크다면 `cnt` 값을 올려주고, 끝나는 시간을 다음 회의시간의 끝나는 시간으로 갱신한다.

### 6.3 Huffman Code 알고리즘

Huffman code는 문자열을 효율적으로 코드화하는 알고리즘이다. 우리가 사용하는 문자 abcd와 같은 알파벳은 사실상 2진수로 표현된다. a=01, b=10, ... 이렇게 비트로 컴퓨터는 알파벳을 읽는다.

이러한 코드의 비트 수가 적으면 적을 수록 컴퓨터 메모리는 이득을 볼 것이다. 이를 위해서 문자열을 효율적으로 코드화할 필요있고, 이와 같은 알고리즘이 나오게 되었다.

> 효율성을 좋게 하려고 구성할 때, **반드시 encoding과 decoding 에 오차가 있으면 안된다.** 예를들어, 같은 100101010 을 어떤것은 abc 로 읽을 수도 있고, bcb 로 읽을수도 있으면 안된다는 뜻이다.

a가 16번, b가 10번, c가 2번 나온다고 가정하자. 길이가 고정된 그냥 이진 코드라면 16 _ 2 + 10 _ 2 + 2 \* 2 = 56개의 비트가 필요하다.

Huffman code는 문자열을 포함하는 코드인 0과 1의 나타냄을 최소로 하여 위보다 적은 메모리 공간을 사용하게 하는 알고리즘이다.

따라서 Huffman code는 **가장 많이 나오는 문자열에 가장 짧은 코드를 부여하는 방법**을 선택하였다.

Huffman Code 알고리즘의 pseudocode 는 다음과 같다 :

```
huffman(C, prob) {
	for each(x in C) {
		add x to Q sorted by prob[x]
	}
	for (i=1 to |c|-1) {
		z = new internal tree node
		left[z] = x = extract-min from Q
		right[z] = y = extract min from Q
		prob[z] = prob[x] + prob[y]
		insert z into Q
	}
	return the last element left in Q as the root
}
```

시간복잡도: O(NlogN)

이 알고리즘의 핵심은 큐에 빈도수가 최소인 것을 담아서 큐에 있는 값으로 트리르 만드는 것이다.

예제를 이용해서 설명하자면 a: 05, b:48, c: 07, d:17, e:10, f,:13 이라고 주어질 때 다음과 같이 실행된다.

![[huffmancode.png]](/imgs/huffmancode.png)

1. 빈도수가 가장 작은 값 두개(a, c)를 구하고, 그 합(12)을 부모 노드로 설정하고 두 값을 자식으로 둔다.
2. 12보다 빈도수가 작은 문자열을 탐색하고 발견하면 12와 그 문자열(e)를 자식으로 하는 노드를 생성하고, 그 부모노드의 값은 위처럼 둘의 합(22)으로 이루어진다.
3. 다시 22보다 빈도수가 작은 문자열을 탐색하고, 두개가 나오면 그 두개를 가지고 다른 트리를 만든다. 그 후 둘을 연결한다.
4. 위와 같은 과정을 반복하면 아래의 그림이 나온다. 트리의 각 노드의 왼쪽 자식 연결은 0 오른쪽은 1로 두어서 각 문자열의 코드를 부여한다.

여기서 가장 작은 값을 선택하는 과정이 그리디 요소라고 볼 수 있다.
