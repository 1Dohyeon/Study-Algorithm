### 7.1 원시매칭

문자열 매칭은 어느 텍스트 문자열 `A[]` 에서 패턴 문자열 `P[]` 가 존재하는지 확인하는 문제이다. 이 문제에는 여러 알고리즘이 존재하는데 원시 매칭은 단순 반복문을 통해서 `A[]` 안에 `P[]` 가 있는지 확인한다.

**pseudocode**
```
naiveMatching(A, P) 
{ 
	▷ n : 배열 A[ ]의 길이, m : 배열 P[ ]의 길이 
	for i ← 1 to n- m+1{ 
		if (P[1… m] = A[ i… i+ m-1]) 
		then A[i] 자리에서 매칭이 발견되었음을 알린다; 
	} 
}
```
- A[1...n] : 텍스트 문자열, P[1...m] : 패턴 문자열 (n>m)
- 기본적으로 전부 탐색하는 방법으로 시간복잡도는 **O(mn)** 이다.

---
### 7.2 Automata

**7.2.1 정의**

(유한)오토마타(Automata) 알고리즘은 문자열 매칭을 위한 알고리즘이다. 이 알고리즘은 매칭을 상태의 전이로 나타낸다. 문자열을 하나씩 읽으면서 현재 상태를 변경하는 방식으로 작동한다.

**7.2.2 예시**
예시를 들며 설명하자면 다음과 같다 :

**ababaca를 체크하는 오토마타**
- 오토마타 구성요소
	- `Q` : 상태 집합
	- `q0` : 시작 상태
	- `F` : 목표 상태들의 집합 
	- `∑` : 입력 알파벳 
	- `δ` : 상태 전이 함수
	
- 문자열 `S` 에서 `ababaca` 가 있는지 체크하기 위해서 `Q` 상태집합을 `{0, 1, 2, 3, 4, 5, 6, 7}`로 둔다.
	- `0`은 아무것도 찾지 못한 경우이고, `7`은 마지막 `a`까지 찾은 경우이다.
	- 따라서 그 사이의 수는 각 알파벳을 찾은 후 갖는 상태이다.
	
>상태를 정의한다는 의미로 동적 프로그래밍을 생각하면 이해하기 쉽다. `dp[0] = [], dp[1] = [a], dp[2] = [a, b] ... dp[7] = [a, b, a, b, a, c, a]` 로 생각하여 원하는 문자가 안나와도 상태를 전환하며 굳이 처음으로 안돌아가도 된다.
	
1) 아무것도 못찾은 상태를 `0`으로 두고 시작
	- `a`를 찾았을 경우 상태 `1`로 전이.
	- 못 찾았을 경우 그대로 `0`.
2) `a`를 찾은 `1`상태
	- `a`를 찾은 경우 : `0`이 아닌 자기 자신의 상태인 `1`로 유지.
	- `b`를 찾은 경우 : `2`상태로 전이.
	- 다른 알파벳을 찾은 경우 : 전환할 상태가 없으므로 시작 상태인 `0`으로 전이.
3) `ab`까지 찾은 `2` 상태
	- `a` : 원하는 문자열이므로 `3` 상태로 전이.
	- `b` : `abb`에서는 다시 돌아갈 상태가 없으므로 시작 상태인 `0`으로 전이. 다른 알파벳도 마찬가지.
4) `aba`까지 찾은 `3` 상태
	- `a` : `abaa`에서 돌아갈 수 있는 경우는 `a`를 찾은 상태인 `1`이 가장 최근이므로 `1`로 전이.(돌아가는 상태를 찾기 어려우면 **각 상태에서의 알파벳을 보고 맨 끝자리부터 겹치는 알파벳을 찾아보면 된다. ex) `abaa`에서 `1`상태인 `a` 겹침, `2` 상태인 `ab`, `3`상태인 `aba`는 `abaa`의 끝자리인 `a`와 `baa`에서는 마지막 `a`만 겹침을 알 수 있다. 따라서 `1`상태로만 전이 할 수 있다.**)
	- `b` : 목표 문자열이므로 `4` 상태로 전이.
	- 다른 알파벳을 찾은 경우 겹치는 상태가 없으므로 시작상태인 `0`으로 전이.
5) `abab`까지 찾은 `4`상태
	- `a` : 목표 문자열이므로 `5` 상태로 전이.
	- `b` : 끝자리 `bb`로 겹치는 것이 없으니 시작상태인 `0`으로 전이, 다른 알파벳도.
6) `ababa`까지 찾은 `5`상태
	- `c` : 다음 상태인 `6`으로 전이.
	- `b` : 앞에 `abab`까지 겹치므로 `4` 상태로 이동하여 `abab`였을 때의 상태로 전이.
	- `a` : `~baa`로 겹치는 상태는 마지막 `a` 뿐이므로 `1`상태로 전이.
2) `ababac`까지 찾은 `6`상태
	- `a` : 다음 상태인 `7`로 전이.
	- `c` : `ababacc`는 기존 상태에서 겹치는 상태가 없으므로 `0`으로 전이.
	- `b` : 위와 같음. `a`를 제외한 나머지 알파벳이 나오면 `0`으로 전이.
3) `ababaca`까지 찾은 `7`상태
	- 찾으려는 문자열을 하나를 찾았기 때문에 찾았음을 알리고, 계속 탐색.
	- `a`를 찾은 경우 : `aa` 반복되는 상태가 없으므로 `a` 하나만 찾은 `1`상태로 전이.
	- `b`를 찾은 경우: `ababacab`에서 `ab`부터 다시 시작할 수 있으므로 `2`로 전이.
	- 다른 알파벳을 찾은 경우(ex. `c`): `ababacac`에서 `ac` 상태가 있는 것처럼 보이지만 앞에까지 겹치는 상태가 없다. 따라서 시작상태인 `0`으로 전이.

**7.2.3 pseudocode**
```
FA-Matcher (A, δ , f ) 
// f : 목표 상태 
{ 
	// n: 배열 A[ ]의 길이 
	q ← 0;    // 시작 상태
	for i ← 1 to n { 
		q ← δ (q, A[i]); 
		if (q = f ) then A[i-m+1]에서 매칭이 발생했음을 알린다; 
	} 
}
```
시작 상태`0`에서 시작하고, 문자열의 문자를 하나씩 읽어 찾고 싶은 문자열이 나오면 상태 전이를 한다. 최종 상태에 이르면 매칭되는 문자열을 찾은 것이다. 찾았다고 그만두는 것이 아니라 계속 진행한다.

수행시간은 `Θ(n + |∑|m)`이다.(상태 전이 함수 테이블(m x ∑) 구성 시간)
총 수행시간: `Θ(n + |∑’|m+ |∑|)`

---
### 7.3 KMP

**7.3.1 정의**

오토마타 알고리즘 을 이용한 매칭 방법과 비슷하다. 매칭에 실패했을 때 돌아갈 상태를  π 배열 담는다. 이때 원래 들어와야 하는 알파벳이 들어왔다고 가정하고 앞에 중복되는 것이 있나 살펴 본 후 이동한다.

**7.3.2 예시**

- `ababaca` 라는 문자열을 찾는다고 가정.
- `P[] = [a, b, a, b, a, c, a]`
- `π[]` <- 매칭에 실패했을 때 돌아갈 곳에 대한 상태를 저장
- ex) `banana`에서 앞에 `ana`는 접두사, 뒤에 `ana`는 접미사. 접두사의 꼬리와 접미사의 머리 `a`는 공유된다. 이를 설명하는 이유로는, 접두사와 접미사의 크기로 돌아갈 수 있는 상태를 판단하기 때문이다. 
- 오토마타에서는 돌아갈 곳이 없다면 `0`상태로 돌아가지만, KMP 알고리즘에서는 돌아가야 할 경우 `접두사+1` 칸으로 돌아간다. 보통은 `접두사` 크기만큼만 움직이면 되지만, 책마다 기준이 전부 다르다. 설명이 어려움으로 아래 예시에서 자세히 설명.
	
- `ababaca` 순서대로 `π`의 상태
1) `a`, `m=1`
	-  이때의 상태는 `1`로 가야한다. 
	- `π`에는 매칭 실패시 이동할 상태를 저장하기 때문에 π의 첫번째 칸은 상태 처음 상태 `0`의 값을 가진다.(인덱스는 0부터지만 보기 편하게 1로 가정) 
	- `π[1] = 0`
2) `b`, `m=2`
	- `ab` 상태`k`는 `2`를 가진다. 
	- `b`를 찾지 못했기에 `π`는 `a`만 있는 상태로 돌아가야 한다. 
	- `π[2] = 1(접두사(0) + 1)`
3) `a`, `m=3`
	- `aba` 상태는 `3`
	- `a`를 찾지 못한 경우 `ab`의 상태에서 돌아갈 방법을 찾아야한다. 접두사와 접미사가 딱히 존재하지 않으니 처음 `a`만 있던 상태인 `1`로 돌아간다. 
	- `π[3] = 1(접두사(0) + 1)`
4) `b`, `m=4`
	- `abab` 상태는 `4`
	- `b`를 찾지 못했을 경우 `aba`에서 `b`를 기준으로 접두사 `a`, 접미사 `b`를 찾을 수 있다. 
	- `π[4] = 2(접두사(1) + 1)`
5) `a`, `m=5`
	- `ababa` 상태는 `5`
	- `a`를 찾지 못했을 경우 `abab`에서 접두사는 앞의`ab`, 접미사는 뒤의 `ab`이다. 
	- 따라서 `π[5] = 3(접두사(2) + 1)`
6) `c`, `m=6`
	- `ababac` 상태는 `6`
	- `c`를 찾지 못한 경우인 `ababa`에서 중간 `a`를 공유하는 접두사 `aba`, 접미사 `aba`가 있음을 알 수 있다.
	- `π[6] = 4(접두사(3) + 1)`
7) `a`, `m=7`
	- `ababaca` 상태는 `7`
	- `a`를 찾지 못한 경우인 `ababac`에서 접두사와 접미사를 찾을 수 없다.(간혹 앞에 `ababa`에서 찾으면 안되냐고 하는데, 맨뒤 알파벳이 꼭 포함 되어야한다. 따라서 `c`는 뒤에서만 찾을 수 있고, 앞에서는 못찾기 때문에 접두사와 접미사는 없다.)
	- `π[7] = 1(접두사(0) + 1)`
	- **원하는 문자열을 찾았기 때문에 찾았음을 알린다.**
8) `m+1`
	- 다음 알파벳을 찾지 못한 경우인 `ababaca`에서 첫`a`와 끝`a`가 접두사 접미사이다. 
	- `π[8(m+1)] = 2(접두사(1) + 1)`
	
최종적으로 `π[] = [0, 1, 1, 2, 3, 4, 1, 2]`

**7.3.3 pseudocode**
```
KMP(A[ ], P[ ]) {	// n: 배열 A의 길이, m: 배열 P의 길이
	preprocessing(P); 	// 수행시간 Θ(m)
    i ←1; 				// 본문 문자열 포인터
	j ←1; 				// 패턴 문자열 포인터
	
    while (i ≤ n) {
		if (j = 0 or A[i] = P[j]) then { 
        	i++; j++; 
        } else j ← π[j];
        if (j = m+1) then {
			A[i-m]에서 매칭이 일어났음을 알린다;
			j ← π[j];
        }
	}
}
```
수행시간 : `Θ(n)`

---
### 7.4 Rabin-Karp

**7.4.1 수치화 후 문자열 매칭 알고리즘**

이 알고리즘은 문자열 패턴을 숫자로 바꾸어서 문자열 비교를 수치화를 통해 비교한다. 예를 들어 a, b, c, d가 있을 경우 각각 0, 1, 2, 3으로 수치화를 한다.

하지만 이 방법에도 문제점이 있다. 수치화 작업이 부담되기도 하고, 수치가 커져서 오버플로우가 발생 할 수도 있다. 이 두가지 문제점을 해결하며 문자열 매칭을 수행하는 것이 중요하다.

**7.4.2 수치화 작업 예시**

`A[i ... i+m-1]`에 대응되는 수치의 계산(ex. "eeaab")
- 알파벳이 5개이므로 `d(진수) = 5`
- p(수치화된 문자열) = 4x5^4  + 4x5^3 + 0x5^2 + 0x5^1 + 1x5^0 => `p = 3001`
> p = ∑ 수치화된 알파벳 x d^m               (m= (d-i) (i=1 to d))

이제 A[] 가 `acebeeaabadcce` 일 경우 p를 구한 공식대로 `a1 = acebe, a2 = cebee, ... `한 칸씩 밀려가며 각 알파벳을 수치화한다. 수치화 후 p와 일치하면 문자열을 찾은 것이다.

하지만 이렇게 하나하나 수치화를 한다면 시간복잡도는 `Θ(mn)`로, 원시적인 매칭(Native Matching)보다 나은게 없다. 하지만 이 문제는 바로 해결할 수 있다.

`acebeeaabadcce` 에서 `a1 = 0x5^4  + 2x5^3 + 4x5^2 + 1x5^1 + 4x5^0` 임을 알 수 있다.
또한 `a2 = 2x5^4 + 4x5^3 + 1x5^2+ 4x5^1 + 4x5^0` 임을 알 수 있다. 

여기서 공통된 점을 발견할 수 있다. `a1`의 첫번째 요소인 `2x5^4`를 빼고 `d`만큼을 곱한다. 그 후에 `a2`의 마지막 요소만 더한다면 `a2` 전체 식이 나오게 된다. 이로써 수행시간을 단축시킬 수 있다. 
- ai의 마지막 요소 = c

> ai = d(ai-1 - (d^m-1)xA[i-1]) + c


**7.4.3 pseudocode**
```
basicRabinKarp(A, P, d) {		// n : 배열 A의 길이, m : 배열 P의 길이 
	p ← 0; a1 ← 0; 
    for i←1 to m {				// 패턴P의 수치값 p와 a1 계산
		p ← dp + P[i];
		a1 ← da1 + A[i]; 
    }
	if (p = a1) then A[1] 자리에서 매칭이 일어났음을 알린다; 
    for i ← 2 to n-m+1	{
		ai ← d(ai-1 – dm-1A[i-1]) + A[i+m-1];
		if (p = ai) then A[i] 자리에서 매칭이 일어났음을 알린다; 
    }
}
```
수행 시간은 `Θ(n)`시간으로 `Θ(mn)`보다 줄어들었다. 하지만 이것은 **라빈-카프(Rabin-Karp) 알고리즘이 아니다.**

아직 위 알고리즘에서는 문자 집합 크기`d`와 패턴의 길이 `m`에 따라 `ai`가 매우 커질 수 있다는 문제점을 가지고 있다. 따라서 레지스터의 용량 초과로 오버플로우가 발생될 가능성이 있다.

**7.4.4 Rabin-Karp**

**나머지 연산(modulo)** 을 통해서 `ai`의 크기를 제한할 수 있다. 
기존 식인 `ai = d(ai-1 - (d^m-1)xA[i-1]) + A[i+m-1] `대신에 `bi = (d(bi-1 - ((d^m-1) mod q)xA[i-1]) + A[i+m-1]) mod q` 사용한다.  이때 `q`를 충분히 큰 소수(prime number)로 정한다.

```
RabinKarp(A,P,d,q) {		// n:배열A의길이, m:배열P의길이 {
	h ← 1;
	for i ← 1 to m-1
		h ← dh mod q;		// h 계산(= dm-1 mod q)
	p ← 0; b1 ← 0; 
    for i ← 1 to m {
		p ← (dp + P[i]) mod q; 		// 패턴 P의 수치값 p 계산
        b1 ← (db1 + A[i]) mod q;	// b1 계산
	}
	for i ← 1 to n-m+1{
		if (i ≠ 1) then bi ← (d(bi-1 – hA[i-1]) + A[i+m-1]) mod q; 
        if (p = bi) then
			if (P[1...m] = A[i...i+m-1]) then // 진짜 매칭인지 알아봄 
            	A[i] 자리에서 매칭이 일어났음을 알린다;
}
```
수행시간 : 매칭 횟수가 상수 번이면 `Θ(n)`. 즉, 평균 수행시간 = `Θ(n)`
최악의 경우 : `Θ(mn)` (모든 문자가 동일한 경우)