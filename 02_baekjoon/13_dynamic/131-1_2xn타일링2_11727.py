'''
d[n]을 2xn크기의 타일을 깔 때의 경우의 수라고 하자.
d[0]=0
d[1]=1
d[2]=3
d[3]=5
d[4]=11

n>=3일때부터는 (n-1)+2(n-2)이긴 하지만 이 식이 저 규칙만 보고는 바로 떠오르지 않는다.

하지만 그림으로 보면 쉽게 알아차릴 수 있다.(03_11727참고용그림 참고)

우선 d[0],d[1],d[2]까지는 경우의 수를 쉽게 구할 수 있다.
d[3]을 바로 구하기 전인 d[3-1]에서 세로 타일을 놓는 경우의 수는 한개밖에 없다.
그리고 두단계 전인 d[3-2]에서는 가로타일 두개를 놓는 경우의수와 2x2사이즈의 타일의 놓는 경우의 수 두개가 있다.
세로를 넣는 경우의 수를 포함하지 않는 이유는 d[3-1]에서 세로를 넣는 경우의 수와 중복되기 때문이다.
즉 d[3]은 d[2]의 경우의 수와 d[1]의 경우의 수의 2배임을 알 수 있다.
'''

n=int(input())
d=[0,1,3]   # 다이나믹 문제를 풀 때 이와같이 배열을 문제 범위까지 만들지 않고 초기 배열만 설정하면서 배열을 선언하고

for i in range(3,1001): # for문과
    d.append(d[i-1]+2*d[i-2])   # append를 통해서 배열의 크기를 늘려 마지막쪽에 원소를 집어 넣어주는 방법도 있고
                                # 04_1,2,3,더하기_9095처럼 'd=[0]*12' 이런 식으로 기본값과 크기를 지정하고
print(d[n]%10007)               # 고정값은 따로 적은 후 append를 이용하지 않고 for문에서 d[i]= ... 이런식으로 
                                # 원래 있던 배열의 기본값 0을 바꿔가면서 다이나믹 문제를 풀 수 있다.
                                # 어떤 경우든지 시간 복잡도는 같기 때문에 편한걸로 하면 된다.
                                
'''
중요한 것은 append가 언제 쓰이느냐이다. 배열이 꽉 찾지만 크기를 늘려가면서 마지막쪽에 원소를 추가하는 것이 'append'이다.
'='로 배열을 채우기 위해서는 우선 크기를 확인하고 채우고자 하는 원소에 기본값이 있는지 체크해야한다. 
'''



