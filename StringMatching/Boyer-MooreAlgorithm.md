### 정의 

> 보이어-무어 알고리즘은 **패턴의 오른쪽부터 비교**를 한다.

오른쪽부터 비교를 하며 매치되지 않는다면 그 다음으로 매칭되는 것을 찾는다.

매칭이 되었다면, 그곳으로 바로 점프를 한다.

---
### 예제

텍스트 `A[]: PLACE IN DRY EVERY`
패턴 `P[]: EVERY`

1) 위 예시를 보면 처음에 `A[]의 E`와 `P[]의 Y`가 맞지 않아서 끝에서부터 탐색하여 `P[]의 E`를 찾고 그만큼 점프를 뛴 것을 알 수있다.
2) 그 후 다시 끝자리`Y`와 `I`를 비교하는데 겹치는 것이 없자 바로 5칸을 점프하였다.
3) 끝에서부터 다시 탐색하여 `Y와 R`은 겹쳤고, `E`까지 와서 `D`와 안겹치는 요소를 찾게 되었다. 그 이후 원소도 `D`와 겹치는 것이 없으므로 3칸을 전부 점프한다.
4) 위 과정을 반복하여 찾는다.

**패턴에 대한 점프 정보 준비**
몇 칸을 점프하는지 페이지에 저장을 해둘 수도 있다.
예시로 다음과 같은 문자가 있다고 해보자.

`P[]: TIGER`

보기 편하도록 아래에 숫자로 칸을 나누었다.
1   2   3   4   5
`P[]: T, I, G, E, R`

5번째 칸이 R일 경우, E일 경우, G일 경우, I일 경우, T일경우 몇칸을 뛸 수 있는지 값을 저장해두는 것이다. 보통은 이렇지만 교재에서는 맨마지막 문자는 왜인지 모르겠지만 5칸(최댓값)을 뛴다고 하고 그 다음인 E부터 계산한다.
- 5번째 자리가 `E`일경우 1칸 뛸 수 있다.
- 5번째 자리가 `G`일경우 2칸 뛸 수 있다.
- 5번째 자리가 `I`일경우 3칸 뛸 수 있다.
- 5번째 자리가 `T`일경우 4칸 뛸 수 있다.

따라서 아래와 같은 테이블이 만들어진다.

오른쪽 끝문자 : T / I / G / E / R / 기타
jump               : 4 / 3 / 2/ 1 / 5 /    5

그렇다면 중복되는 알파벳이 있을 경우는 어떨까?


**패턴 “rational”에 대한 점프 정보**
위 tiger 예시처럼한다면 아래와 같이 만들어진다.

오른쪽 끝문자 : R / A / T / I / O / N / A / L / 기타
jump               : 7 / 6 / 5 / 4 / 3  / 2 /  1 / 8 /   8

위 예시를 보면 `A`가 겹치는 것을 알 수 있다. 이때 끝자리부터 탐색하기 때문에 끝자리인 `A`, 즉 가장 작은 점프값을 선택하면 된다.

오른쪽 끝문자 : R / T / I / O / N / A / L / 기타
jump               : 7 / 5 / 4 / 3  / 2 /  1 / 8 /   8

---
### 수도 코드

```
BoyerMooreHorspool(A[ ], P[ ]) 
{ ▷ n : 배열 A[ ]의 길이, m : 배열 P[ ]의 길이 
	computeSkip(P, jump); 
	i ← 1; 
	while (i ≤ n ? m+1) { 
		j ← m; k ← i + m ?1; 
		while ( j > 0 and P[j] = A[k]) { 
			j--; k--; 
		} 
		if (j = 0) then A[i] 자리에서 매칭이 발견되었음을 알린다; 
		i ← i + jump[A[i + m ? 1]]; 
	} 
}
```
- 최악의 경우 수행시간: Θ(mn)
- 입력에 따라 다르지만 일반적으로 Θ(n)보다 시간이 가볍다
- Best case: Θ(n / m)