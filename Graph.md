## 최소 신장 트리

### 4.1 Prim 알고리즘

프림(Prim) 알고리즘은 최소신장트리(Minimum Spanning Trees)를 구하는 알고리즘이다. Minimum Spanning Trees 는 모든 꼭짓점을 사이클 없이 가능한 **최소** 총 가중치로 연결하는 알고리즘이다.

이때 트리는 싸이클이 없는 연결 그래프여야한다. 또한 무향 연결 그래프(connected graph)여야 한다. 이는 모든 정점간에 경로가 존재하는 그래프를 의미한다.

**pseudocode**

```
Prim(G, r)
▷ G=(V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
	S ← Ф ; ▷ S : 정점 집합
	for each u∈V
		du ← ∞ ;

	dr ← 0 ;
	while (S≠V){ ▷ n회 순환된다
		u ← extractMin(V-S, d);
		S ← S ∪{u};
		for each v∈L(u) ▷ L(u) : u로부터 연결된 정점들의 집합
			if (v∈V-S and wuv<dv) then dv ← wuv;
	}
}

extractMin(Q, d)
{
	집합 Q에서 d값이 가장 작은 정점 u를 리턴한다;
}
```

> 수행시간: O(|E|log|V|): - 힙 이용

1. 방문한 정점을 담을 배열 `S`를 선언, 초기는 당연히 공집합
2. 반복문을 돌며 모든 정점을 무한대로 설정 -> 나중에 비교 후 최솟값으로 결정내기 위함
3. 순환을 하기 위한 첫번째 정점 `dr` 은 당연히 0으로 설정
4. `S`가 모든 정점 `V`를 포함할 때까지 다음을 반복 :
   1. `V-S`에서 `du` 값이 가장 작은 정점 `u`를 찾아내고, 이를 `S`에 추가
   2. `u`의 모든 인접 정점 `v`에 대해 `v`가 `V-S`에 속하고, `wuv`가 `dv`보다 작으면 `dv` 값을 갱신
5. 최소 신장 트리를 찾을 때까지 계속 반복(`extractMin(Q, d)` 함수는 주어진 집합 `Q`에서 `d` 값이 가장 작은 정점 `u`를 찾아 리턴하는 함수이다. 이 함수는 Prim 알고리즘에서 사용되어 `V-S`에서 최소 `du` 값을 갖는 정점 `u`를 찾아내기 위해 호출된다.)

![[프림1.png]](/imgs/프림1.png)
`r` 부터 시작해서 `S` 집합에 있는 정점 중 다른 정점으로 갈 수 있는 경우 중 작은 경우를 `S` 배열 안에 담음.
![[프림2.png]](/imgs/프림2.png)

### 4.2 Kruskal 알고리즘

Kruskal 알고리즘도 Prim 알고리즘처럼 최소신장트리를 구하는 알고리즘이다. Kruskal은 Prim과 달리 정점과 연결된 간선의 가중치를 비교하는 것이 아니라 정점과 연결이 되어있든 말든 가장 작은 가중치를 가진 간선을 찾는 방식으로 진행한다.

**pseudocode**

```
Kruskal (G, r)
{
	1. T ← Ф ; ▷ T : 신장트리
	2. 단 하나의 정점만으로 이루어진 n 개의 집합을 초기화한다;
	3. 간선 집합 Q(=E)를 가중치가 작은 순으로 정렬한다;

	4. while (T의 간선수 < n-1) {
		Q에서 최소비용 간선 (u, v)를 제거한다;
		정점 u와 정점 v가 서로 다른 집합에 속하면 {
			두 집합을 하나로 합친다;
			T ← T∪{(u, v)};
		}
	}
}
```

> 수행시간: O(ElogV)

1. `T`: 최소 신장 트리를 나타내는 변수를 빈 집합으로 초기화한다.
2. 각 정점을 단일 원소로 가지는 n개의 집합을 초기화한다. 이는 처음에는 모든 정점이 독립된 집합에 속해 있다는 것을 의미함.
3. 간선 집합 `Q`(=E)을 가중치가 작은 순으로 정렬한다.
4. `T`에 포함된 간선의 수가 `n-1`이 될 때까지 다음을 반복 :
   1. `Q`에서 최소 비용 간선 `(u, v)`를 제거합니다.
   2. 만약 정점 `u`와 정점 `v`가 서로 다른 집합에 속한다면(즉, 서로 연결되지 않은 집합에 속한다면), 두 집합을 하나로 합친다. 이를 통해 두 정점이 같은 최소 신장 트리에 속하게 되며, `T`에 해당 간선을 추가한다.

![[크루스칼1.png]](imgs/크루스칼1.png)

![[크루스칼2.png]](imgs/크루스칼2.png)

주의할 점은 f->g 과정처럼 간선을 찾았는데 만약 순회가 생긴다면 제외시킨다.

---

## 위상정렬

### 4.3 TopologicalSort 알고리즘

위상정렬(TopologicalSort)이란 **싸이클이 없는 유향 그래프**에서 각 정점들을 정렬하는 것이다. 이때 정점 x에서 정점 y로 가는 간선이 있으면 x는 반드시 y보다 앞에 위치해야한다.

![[위상정렬.png]](/imgs/위상정렬.png)

위상정렬 알고리즘으로는 2가지가 대표적이다. 우선 첫번 째 알고리즘의 pseudocode는 다음과 같다 :

```
topologicalSort1(G, v) {
	for ← 1 to n {
		진입간선이 없는 정점 u를 선택한다;
		A[i] ← u;
		정점 u와, u의 진출간선을 모두 제거한다;
	}
	▷ 이 시점에 배열 A[1…n]에는 정점들이 위상정렬되어 있다
}
```

> 수행 시간: Θ(|V|+|E|)

1. `for i ← 1 to n`: 이 반복문은 총 n번 반복된다. 여기서 n은 그래프 G의 정점의 수를 나타낸다.
2. `진입간선이 없는 정점 u를 선택한다`: 진입간선이 없는 정점은 해당 정점으로 들어오는 간선이 없는 정점을 의미한다. 즉, 해당 정점으로 들어오는 선행 작업이 없는 정점이다.
3. `A[i] ← u`: 현재 인덱스 i에 해당하는 배열 A의 원소에 선택한 정점 u를 할당한다. 이는 위상 정렬된 순서를 저장하는 배열이다.
4. `정점 u와, u의 진출간선을 모두 제거한다`: 선택한 정점 u와 u에서 나가는 모든 간선을 그래프에서 제거한다. 이는 다음 반복에서 u가 선택되지 않도록 진행된 간선들을 제거하는 것을 의미한다.
5. 반복이 끝나면 배열 A[1…n]에는 그래프의 정점들이 위상 정렬된 순서대로 저장된다. 배열 A는 그래프의 위상 정렬 결과를 나타낸다.

두번 째 방법의 pseudocode는 다음과 같다 :

```
topologicalSort2(G)
{
	for each v∈V
		visited[v] ← NO;
	for each v∈V ▷ 정점의 순서는 무관
		if (visited[v] = NO) then DFS-TS(v);
}

DFS-TS(v)
{
	visited[v] ← YES;
	for each x∈L(v) ▷ L(v): v의 인접 리스트
		if (visited[x] = NO) then DFS-TS(x);
	연결 리스트 R의 맨 앞에 정점 v를 삽입한다;
}
```

> 수행 시간: Θ(|V|+|E|)
> 알고리즘이 끝나고 나면 연결 리스트 R에는 정점들이 위상정렬된 순서로 매달려 있다.

> `topologicalSort2(G)` 함수 :

1. `visited[v] ← NO:` 모든 정점에 대해 방문 여부를 나타내는 배열 `visited`를 초기화한다. 처음에는 모든 정점이 방문되지 않은 상태이다.
2. 만약 정점 `v`가 아직 방문되지 않았다면(`visited[v] = NO`라면), `DFS-TS(v)` 함수를 호출하여 해당 정점을 시작으로 깊이 우선 탐색을 수행한다.
   > `DFS-TS(v)` 함수 :
3. `visited[v] ← YES:` 현재 정점 `v`를 방문했다고 표시한다.
4. `for each x∈L(v):` 정점 `v`의 인접 리스트 `L(v)`에 속하는 모든 정점 `x`에 대해 다음을 반복한다.
   1. 만약 정점 `x`가 아직 방문되지 않았다면(`visited[x] = NO`), `DFS-TS(x)` 함수를 재귀적으로 호출하여 깊이 우선 탐색을 수행한다.
5. `연결 리스트 R의 맨 앞에 정점 v를 삽입한다:` DFS가 끝난 후, 현재 정점 `v`를 연결 리스트 `R`의 맨 앞에 삽입한다. 이렇게 하면 `R`에는 위상 정렬된 순서대로 정점들이 저장된다.

![[위상정렬.png]](/imgs/위상정렬.png)
위 그림의 (b)를 생각하면 된다.

1. a부터 dfs 탐색을 시작하면 c를 마주하게 된다. c를 방문했다고 표시한다.
2. 돌아가서 다시 dfs를 하면 e->f를 지나게 되므로 f, e 순으로 방문을 했다고 표시한다.
3. 다시 b로 돌아가면 더이상 이동할 곳이 없게 되므로 g를 진행시킨다: g->d->e ... **e는 방문을 했기때문에 d와 g 순으로 방문했다고 표시**한다.
4. 다시 b로 돌아와서 방문했다고 표시하고, a도 표시한다.
5. 이렇게 되면 c, f, e, d, g, b, a 순으로 표시를 한것이고, 이것들을 **뒤집으면 (b) 형태**가 나오게 된다. 위상정렬1 과는 다르게 **거꾸로 올라가면서 순서를 정렬**한다.

---

## 최단경로

그래프에서 최단 거리란 말 그대로 노드 A에서 노드 B까지의 거리들 중 가장 가중치가 적은 경로를 의미한다.

### 4.4 Floyd-Warshall 알고리즘

Floyd-Warshall 알고리즘도 모든 정점들간의 최단 거리를 구하는 알고리즘이다. 이 알고리즘은 그래프에 싸이클(순환)이 있어도 사용 가능하다. pseudocode는 다음과 같다 :

```
FloydWarshall(G)
{
	for i ← 1 to n
		for j ← 1 to n
			d0ij ← wij;
	for k ← 1 to n ▷ 중간정점 집합 {1, 2, …, k}
		for i ← 1 to n ▷ i : 시작 정점
			for j ← 1 to n ▷ j : 마지막 정점
				dkij ← min {dk-1ij , dk-1ik + dk-1kj};
}
```

> 수행시간: Θ(|V|^3), 문제의 총 수 Θ(|V|^3), 각 문제의 계산에 Θ(1)

플로이드-워셜 알고리즘은 다익스트라 알고리즘과는 다르게 음의 간선도 사용할 수 있다. 벨만-포드 알고리즘이 무한루프에 빠진다면 이 방법을 사용하면 된다.

![[플로이드워샬1.png]](/imgs/플로이드워샬1.png)
![[플로이드워샬2.png]](/imgs/플로이드워샬2.png)

1. **D(0)** 은 각 정점과 1단계로만 연결된 정점 사이의 가중치들을 전부 matrix안에 담는다. 즉 1행에는 정점1이 갈 수 있는 곳까지의 가중치로 채워진 것이고, 2행에는 정점2가 갈 수 있는 곳의 가중치가 채워진 것이다. 다른 행들도 똑같은 방식으로 채워진 것이다.
2. D(1)은 1을 거쳐서 가는 경우를 채워준다. 1을 거칠 수 있는 노드는 4밖에 없고, 4가 1을 거치고 갈 수 있는 노드는 2, 5, 3이다. `4->1->2`의 가중치는 5이니까 `D[4][2]`를 5로 채운다.
3. `4->1->3`의 가중치는 10이고, `D[4][3]`은 이미 10보다 작은 값이므로 냅둔다.
4. `4->1->5`의 가중치는 -2이고, `D[4][5]`는 원래 비었으니 채워준다.
5. 이렇게 D(2)는 2를 거쳐서, D(3)은 3을 중간노드로 거쳐서, ... , 마지막 5를 거치는거까지 계산하면 된다. 이미 작은값이면 갱신할 필요가 없다.

---

## 싸이클이 없는 그래프(DAG)에서의 최단 경로

DAG란 Directed Acyclic Graph의 약자로 싸이클이 없는 유향 그래프를 의미한다.

### 4.5 Dijkstra 알고리즘

Dijkstra의 알고리즘은 시작 정점으로부터 출발하여 각 단계에서 최단 거리를 가진 정점을 선택하고, 그 정점을 통해 도달할 수 있는 ==다른 정점들의 최단 거리를 업데이트==하는 알고리즘이다.

Dijkstra의 알고리즘의 pseudocode는 다음과 같다 :

```
Dijkstra(G, r)
▷ G=(V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
	S ← Ф ;  ▷ S : 정점 집합
	for each u∈V
		d[u] ← ∞ ;
	d[r] ← 0 ;

	while (S≠V){ ▷ n회 순환된다
		u ← extractMin(V-S, d);
		S ← S ∪{u};
		for each v∈L(u) ▷ L(u) : u로부터 연결된 정점들의 집합
			if (v∈V-S and d[u]+w[u, v] < d[v] ) then {
				d[v] ← d[u] + w[u, v];
				prev[v] ← u;
			}
	}
}
extractMin(Q, d[])
{
	집합 Q에서 d값이 가장 작은 정점 u를 리턴한다;
}
```

> 수행 시간: O(|E|log|V|) - 힙 이용

1. `S`: 이미 최단 경로를 찾은 정점들의 집합을 나타내는 변수를 빈 집합으로 초기화한다.
2. `d[u]`: 시작 정점 `r`로부터 정점 `u`까지의 현재까지의 최단 거리를 나타내는 배열을 무한대로 초기화한다. 시작 정점의 최단 거리는 0으로 초기화한다.
3. `while (S ≠ V)`: 최단 경로를 찾지 않은 정점들이 남아있는 동안 다음을 반복한다.
   1. `u ← extractMin(V-S, d)`: 아직 최단 경로를 찾지 않은 정점 중에서 최단 거리를 가진 정점 `u`를 선택한다.
   2. `S ← S ∪ {u}`: 선택한 정점 `u`를 이미 최단 경로를 찾은 정점들의 집합에 추가한다.
   3. `for each v ∈ L(u)`: 정점 `u`로부터 연결된 모든 정점 `v`에 대해 다음을 수행한다.
      1. 만약 `v`가 아직 최단 경로를 찾지 않은 정점이고, `d[u] + w[u, v] < d[v]`라면, `d[v]` 값을 업데이트하고, `prev[v]` 값을 `u`로 설정한다. 이 과정은 더 짧은 경로를 찾은 경우 최단 거리와 이전 정점을 업데이트한다.
4. `extractMin(Q, d[])`: 주어진 집합 `Q`에서 최소 `d` 값을 갖는 정점 `u`를 찾아 리턴하는 함수이다.

![[다익스트라.png]](/imgs/다익스트라.png)

예제를 통해서 설명하자면 먼저 시작 노드를 제외한 모든 노드의 거리를 나타내는 배열을 무한대로 설정한다. `[0, -, -, -, -, -, -, -]`

시작 노드로부터 이동할 수 있는 정점까지의 경로를 업데이트한다.
`[0, 8, 11, 9, -, -, -, -]`

업데이트 된 노드 중 가장 작은 값을 선택하여, 그 노드에서 이동할 수 있는 정점까지 또 거리를 업데이트 한다. `[0, 8, 11, 9, 18, -, -, -]` 이때 선택된 가장 작은 값은 다른 값으로 변하지 않는다.

위 과정을 반복하여 가장 작은값을 찾아나가면 된다.

### 4.6 Bellman-Ford 알고리즘

Bellman-Ford 알고리즘은 여러번의 루프를 통해 각 정점까지의 최단 경로를 찾는다. **음의 가중치 간선이 포함되어 있을 때도 사용할 수 있다.** 하지만 Bellman-Ford 알고리즘의 시간 복잡도는 O(VxE) 이므로 정점과 간선의 수가 매우 많을 때 비효율적일 수 있다.

Bellman-Ford 알고리즘의 pseudocode는 다음과 같다 :

```
BellmanFord(G, r)
{
	for each u∈V
		du← ∞;
	d[r] ← 0;

	for i ← 1 to |V|-1
		for each (u, v) ∈E
			if (d[u] + w[u, v] < d[v]v ) then {
				d[v] ← d[u] + w[u, v];
				prev[ v] ← u;
			}
	▷ 음의 싸이클 존재 여부 확인
	for each (u, v) ∈E
		if (d[u] + w[u, v] < d[v]v ) output “해없음”;
}
```

> 수행 시간: Θ(|E||V|)

1. `for each u ∈ V`: 모든 정점에 대해 다음을 반복한다.
   1. `du ← ∞`: 시작 정점 `r`로부터 정점 `u`까지의 최단 거리를 무한대로 초기화한다.
   2. `d[r] ← 0`: 시작 정점의 최단 거리는 0으로 초기화한다.
2. `for i ← 1 to |V| - 1`: (정점의 수 - 1)만큼 반복한다. 이는 최단 경로의 길이가 최대 (정점의 수 - 1)임을 고려한 반복이다. 왜냐하면 그래프에서 모든 정점을 방문하는 최단 경로는 최대 (정점의 수 - 1)개의 간선을 가지기 때문이다.
   1. `for each (u, v) ∈ E`: 그래프의 간선에 대해 다음을 반복한다.
      1. 만약 `d[u] + w[u, v] < d[v]`이면 ( **`w[u, v]`는 간선 `(u, v)`의 가중치를 나타낸다** ), `d[v] ← d[u] + w[u, v]`로 업데이트하고, `prev[v] ← u`로 이전 정점을 저장한다. 이렇게 함으로써 현재까지 찾은 최단 경로를 업데이트한다.
3. `음의 싸이클 존재 여부 확인`:
   1. 모든 간선에 대해 다시 한 번 검사하여 음의 싸이클이 존재하는지 확인한다. 음의 싸이클이 존재하면 최단 경로를 찾을 수 없다. 만약 `d[u] + w[u, v] < d[v]`이면 음의 싸이클이 존재한다는 것을 나타내고 "해없음"을 출력한다.

다음 반복에 변화가 없다면 음의 사이클이 있어도 최솟값을 이미 다 구했다는 의미이므로 종료한다.

![[벨만포드.png]](/imgs/벨만포드.png)

처음에는 Dijkstra 알고리즘처럼 시작 정점을 제외한 나머지 정점을 무한대로 초기화하고, 진행할 수 있는 정점의 값을 가중치에 따라 업데이트한다.

업데이트 된 정점을 표시해두고, 그 정점들로 다른 정점을 업데이트 할 수 있다면 다른 정점도 업데이트한다.(이때 업데이트 이전 값이 더 작다면 그대로두면 된다.)

위 과정을 반복하여 업데이트된 정점이 이제 없다면 반복문을 탈출하면 된다.

### 4.7 위상정렬을 이용한 알고리즘

DAG에서의 최단경로는 위상 정렬의 순서를 이용 하여 선형시간에 간단히 구할 수 있다. 이 알고리즘의 pseudocode는 다음과 같다 :

```
DAG-ShortestPath(G, r)
{
	for each u∈V
		du ← ∞;
	dr ← 0;
	G의 정점들을 위상정렬한다;
	for each u∈V (위상정렬 순서로)
		for each v∈L(u) ▷ L(u) : 정점 u로부터 연결된 정점들의 집합
			if (du + wu,v < dv ) then dv ← du + wu,v ;
}
```

> 수행시간: Θ(|V|+|E|)

1. 모든 노드들의 가중치를 무한대로 초기화한다.
2. 시작 지점 `r`은 0의 가중치를 둔다.
3. 위상정렬(4.3 참고)을 한다.
4. `r`부터 시작하여 `r`과 연결된 노드들에 간선 가중치만큼 부여한다.
5. `r`의 바로 다음단계부터 또 `4`번 과정을 반복한다. 이때 가중치가 작아지면 값을 갱신한다.

---

## 강연결요소

### 4.8 StronglyConnectedComponent 알고리즘

이 알고리즘은 그래프에서 가장 긴 순환을 구해서 따로 집합을 만드는 알고리즘이다. pseudocode는 다음과 같다 :

```
stronglyConnectedComponent(G)
{
	1. 그래프 G에 대해 DFS를 수행하여 각 정점 v의 완료시간 f [v] 를 계산한다.
	2. G의 모든 간선들의 방향을 뒤집어 GR을 만든다.
	3. DFS(GR)를 수행하되 시작점을 택할 때, '1.' 에서 구한 f [v]가 가장 큰 정점으로 잡는다.
	4. 앞의 에서 만들어진 분리된 트리들 각각을 강연결요소로 리턴한다.
}
```

> 수행 시간: Θ(|V|+|E|)

![[강연결1.png]](/imgs/강연결1.png)
![[강연결2.png]](/imgs/강연결2.png)

1. (a) -> (b)과정은 맨 왼쪽 아래서부터 dfs탐색을 실행한다. 대각선 아래방향으로 순환을 찾았다. 하지만 1이랑은 연결 안됨을 확인.
2. 번호 4까지 나왔으므로 다시 5부터 순환을 찾음. 중간층 1 5 6 7 8 순환을 찾았다. 2 3 4 순환, 1 5 6 7 8순환 두개를 찾은 단계이다.
3. (b) -> (c) 과정은 나머지 순환인 9와 10을 찾았다.(9 따로 10 따로임)
4. (c) -> (d) 과정은 순환을 뒤집는 과정이다. 이때 1과 4를 바꾸었다. 시작은 기존 1에서 했지만 첫 순환은 아래 2->3->4 이기에 뒤집으면서 1->2->3 순환으로 바꾸었다.
5. 순환끼리 그룹을 짓는다.
