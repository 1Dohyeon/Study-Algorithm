## 최소 신장 트리

### 4.1 Prim 알고리즘

프림(Prim) 알고리즘은 최소신장트리(Minimum Spanning Trees)를 구하는 알고리즘이다. Minimum Spanning Trees 는 모든 꼭짓점을 사이클 없이 가능한 **최소** 총 가중치로 연결하는 알고리즘이다.

이때 트리는 싸이클이 없는 연결 그래프여야한다. 또한 무향 연결 그래프(connected graph)여야 한다. 이는 모든 정점간에 경로가 존재하는 그래프를 의미한다.

**pseudocode**

```
Prim(G, r)
▷ G=(V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
	S ← Ф ; ▷ S : 정점 집합
	for each u∈V
		du ← ∞ ;

	dr ← 0 ;
	while (S≠V){ ▷ n회 순환된다
		u ← extractMin(V-S, d);
		S ← S ∪{u};
		for each v∈L(u) ▷ L(u) : u로부터 연결된 정점들의 집합
			if (v∈V-S and wuv<dv) then dv ← wuv;
	}
}

extractMin(Q, d)
{
	집합 Q에서 d값이 가장 작은 정점 u를 리턴한다;
}
```

> 수행시간: O(|E|log|V|): - 힙 이용

1. 방문한 정점을 담을 배열 `S`를 선언, 초기는 당연히 공집합
2. 반복문을 돌며 모든 정점을 무한대로 설정 -> 나중에 비교 후 최솟값으로 결정내기 위함
3. 순환을 하기 위한 첫번째 정점 `dr` 은 당연히 0으로 설정
4. `S`가 모든 정점 `V`를 포함할 때까지 다음을 반복 :
   1. `V-S`에서 `du` 값이 가장 작은 정점 `u`를 찾아내고, 이를 `S`에 추가
   2. `u`의 모든 인접 정점 `v`에 대해 `v`가 `V-S`에 속하고, `wuv`가 `dv`보다 작으면 `dv` 값을 갱신
5. 최소 신장 트리를 찾을 때까지 계속 반복(`extractMin(Q, d)` 함수는 주어진 집합 `Q`에서 `d` 값이 가장 작은 정점 `u`를 찾아 리턴하는 함수이다. 이 함수는 Prim 알고리즘에서 사용되어 `V-S`에서 최소 `du` 값을 갖는 정점 `u`를 찾아내기 위해 호출된다.)

![[프림1.png]](/imgs/프림1.png)
`r` 부터 시작해서 `S` 집합에 있는 정점 중 다른 정점으로 갈 수 있는 경우 중 작은 경우를 `S` 배열 안에 담음.
![[프림2.png]](/imgs/프림2.png)

### 4.2 Kruskal 알고리즘

Kruskal 알고리즘도 Prim 알고리즘처럼 최소신장트리를 구하는 알고리즘이다. Kruskal은 Prim과 달리 정점과 연결된 간선의 가중치를 비교하는 것이 아니라 정점과 연결이 되어있든 말든 가장 작은 가중치를 가진 간선을 찾는 방식으로 진행한다.

**pseudocode**

```
Kruskal (G, r)
{
	1. T ← Ф ; ▷ T : 신장트리
	2. 단 하나의 정점만으로 이루어진 n 개의 집합을 초기화한다;
	3. 간선 집합 Q(=E)를 가중치가 작은 순으로 정렬한다;

	4. while (T의 간선수 < n-1) {
		Q에서 최소비용 간선 (u, v)를 제거한다;
		정점 u와 정점 v가 서로 다른 집합에 속하면 {
			두 집합을 하나로 합친다;
			T ← T∪{(u, v)};
		}
	}
}
```

> 수행시간: O(ElogV)

1. `T`: 최소 신장 트리를 나타내는 변수를 빈 집합으로 초기화한다.
2. 각 정점을 단일 원소로 가지는 n개의 집합을 초기화한다. 이는 처음에는 모든 정점이 독립된 집합에 속해 있다는 것을 의미함.
3. 간선 집합 `Q`(=E)을 가중치가 작은 순으로 정렬한다.
4. `T`에 포함된 간선의 수가 `n-1`이 될 때까지 다음을 반복 :
   1. `Q`에서 최소 비용 간선 `(u, v)`를 제거합니다.
   2. 만약 정점 `u`와 정점 `v`가 서로 다른 집합에 속한다면(즉, 서로 연결되지 않은 집합에 속한다면), 두 집합을 하나로 합친다. 이를 통해 두 정점이 같은 최소 신장 트리에 속하게 되며, `T`에 해당 간선을 추가한다.

![[크루스칼1.png]](imgs/크루스칼1.png)

![[크루스칼2.png]](imgs/크루스칼2.png)

주의할 점은 f->g 과정처럼 간선을 찾았는데 만약 순회가 생긴다면 제외시킨다.

---

## 위상정렬

### 4.3 TopologicalSort 알고리즘

위상정렬(TopologicalSort)이란 **싸이클이 없는 유향 그래프**에서 각 정점들을 정렬하는 것이다. 이때 정점 x에서 정점 y로 가는 간선이 있으면 x는 반드시 y보다 앞에 위치해야한다.

![[Pasted image 20240125213127.png]]

위상정렬 알고리즘으로는 2가지가 대표적이다. 우선 첫번 째 알고리즘의 pseudocode는 다음과 같다 :

```
topologicalSort1(G, v) {
	for ← 1 to n {
		진입간선이 없는 정점 u를 선택한다;
		A[i] ← u;
		정점 u와, u의 진출간선을 모두 제거한다;
	}
	▷ 이 시점에 배열 A[1…n]에는 정점들이 위상정렬되어 있다
}
```

> 수행 시간: Θ(|V|+|E|)

1. `for i ← 1 to n`: 이 반복문은 총 n번 반복된다. 여기서 n은 그래프 G의 정점의 수를 나타낸다.
2. `진입간선이 없는 정점 u를 선택한다`: 진입간선이 없는 정점은 해당 정점으로 들어오는 간선이 없는 정점을 의미한다. 즉, 해당 정점으로 들어오는 선행 작업이 없는 정점이다.
3. `A[i] ← u`: 현재 인덱스 i에 해당하는 배열 A의 원소에 선택한 정점 u를 할당한다. 이는 위상 정렬된 순서를 저장하는 배열이다.
4. `정점 u와, u의 진출간선을 모두 제거한다`: 선택한 정점 u와 u에서 나가는 모든 간선을 그래프에서 제거한다. 이는 다음 반복에서 u가 선택되지 않도록 진행된 간선들을 제거하는 것을 의미한다.
5. 반복이 끝나면 배열 A[1…n]에는 그래프의 정점들이 위상 정렬된 순서대로 저장된다. 배열 A는 그래프의 위상 정렬 결과를 나타낸다.

두번 째 방법의 pseudocode는 다음과 같다 :

```
topologicalSort2(G)
{
	for each v∈V
		visited[v] ← NO;
	for each v∈V ▷ 정점의 순서는 무관
		if (visited[v] = NO) then DFS-TS(v);
}

DFS-TS(v)
{
	visited[v] ← YES;
	for each x∈L(v) ▷ L(v): v의 인접 리스트
		if (visited[x] = NO) then DFS-TS(x);
	연결 리스트 R의 맨 앞에 정점 v를 삽입한다;
}
```

> 수행 시간: Θ(|V|+|E|)
> 알고리즘이 끝나고 나면 연결 리스트 R에는 정점들이 위상정렬된 순서로 매달려 있다.

> `topologicalSort2(G)` 함수 :

1. `visited[v] ← NO:` 모든 정점에 대해 방문 여부를 나타내는 배열 `visited`를 초기화한다. 처음에는 모든 정점이 방문되지 않은 상태이다.
2. 만약 정점 `v`가 아직 방문되지 않았다면(`visited[v] = NO`라면), `DFS-TS(v)` 함수를 호출하여 해당 정점을 시작으로 깊이 우선 탐색을 수행한다.
   > `DFS-TS(v)` 함수 :
3. `visited[v] ← YES:` 현재 정점 `v`를 방문했다고 표시한다.
4. `for each x∈L(v):` 정점 `v`의 인접 리스트 `L(v)`에 속하는 모든 정점 `x`에 대해 다음을 반복한다.
   1. 만약 정점 `x`가 아직 방문되지 않았다면(`visited[x] = NO`), `DFS-TS(x)` 함수를 재귀적으로 호출하여 깊이 우선 탐색을 수행한다.
5. `연결 리스트 R의 맨 앞에 정점 v를 삽입한다:` DFS가 끝난 후, 현재 정점 `v`를 연결 리스트 `R`의 맨 앞에 삽입한다. 이렇게 하면 `R`에는 위상 정렬된 순서대로 정점들이 저장된다.

![[위상정렬.png]](/imgs/위상정렬.png)
위 그림의 (b)를 생각하면 된다.

1. a부터 dfs 탐색을 시작하면 c를 마주하게 된다. c를 방문했다고 표시한다.
2. 돌아가서 다시 dfs를 하면 e->f를 지나게 되므로 f, e 순으로 방문을 했다고 표시한다.
3. 다시 b로 돌아가면 더이상 이동할 곳이 없게 되므로 g를 진행시킨다: g->d->e ... **e는 방문을 했기때문에 d와 g 순으로 방문했다고 표시**한다.
4. 다시 b로 돌아와서 방문했다고 표시하고, a도 표시한다.
5. 이렇게 되면 c, f, e, d, g, b, a 순으로 표시를 한것이고, 이것들을 **뒤집으면 (b) 형태**가 나오게 된다. 위상정렬1 과는 다르게 **거꾸로 올라가면서 순서를 정렬**한다.

---

## 최단경로

### 4.4 Dijkstra 알고리즘

## 4.5 Bellman-Ford 알고리즘

### 4.6 Floyd-Warshall 알고리즘

---

## 싸이클이 없는 그래프에서의 최단 경로

### 4.7 DAT

---

## 강연결요소

### 4.8 StronglyConnectedComponent 알고리즘
