### 1.1 계수 정렬

**1.1.1 계수 정렬 사용 조건**

정렬하고자 하는 원소들의 값이 O(N) 을 넘지 않는 경우에 사용하는 정렬이다. 즉, 11개의 원소를 정렬하고자 할때 각 원소들을 가진 배열의 최댓값은 11 이하여야 한다.

**1.1.2 계수 정렬 정의**

계수 정렬(Counting Sort)은 정렬 알고리즘 중 하나로, 정수 또는 정수 형태의 데이터를 정렬하는 데 사용된다. 이름 그대로 **계수(빈도수)를 가지고 정렬을 하는 방식**이다.

계수 정렬은 다음과 같은 특징을 갖는다 :

- 비교 기반 정렬 알고리즘이 아님
- 입력 데이터의 범위가 제한되어 있을 때 효과적으로 동작함
- 중복된 값을 가지는 데이터에 대해 잘 동작함

아래는 계수 정렬의 기본 동작 과정이다 :

1. 입력 배열을 순회하면서 각 데이터의 출현 빈도수를 세어 "카운트 배열"에 저장한다. 이때, 카운트 배열의 인덱스는 입력 데이터의 값이며, 각 인덱스의 값은 해당 값의 출현 빈도수를 나타낸다.
2. 카운트 배열을 이용하여 정렬된 결과를 새로운 배열에 저장한다. 이때, 입력 배열의 순서를 유지하면서 정렬한다. 예를 들어, 입력 배열에서 같은 값이 여러 번 나온 경우, 정렬된 결과에서도 같은 값이 여러 번 나오게 된다.
3. 정렬된 결과를 새로운 배열에 저장한 후, 이를 다시 입력 배열에 복사한다.

`A` 라는 배열을 정렬해야할 때, 임시 배열 `B, C` 를 만든다. `B`에는 `A` 배열의 빈도수를 담으면 된다. 예를 들어 `A` 배열에 0이 1개, 1이 3개, 2가 2개 있다면 `B[0] = 1, B[1] = 3, B[2] = 2` 가 될 것이다. 빈도수가 0이라면 당연히 0이 채워진다.

위와 같이 B 배열을 채웠다면 인덱스를 통해서 C 배열에 채워 넣으면 된다. C 배열은 `C[] = [0, 1, 1, 1, 2, 2]` 가 된다. 0, 1의 개수의 합은 4이다. 이 누적 인덱스를 통해서 `C[4]` 자리에는 2가 채워진다.

---

### 1.2 기수 정렬

**1.2.1 기수 정렬 정의**

기수 정렬(Radix Sort)은 비교 기반 정렬 알고리즘이 아닌, 정수나 문자열과 같은 특정한 자료형을 정렬하는 데 사용되는 비교 정렬이 아닌 정렬 알고리즘 중 하나이다. 자릿수(또는 문자의 자릿수)를 기반으로 배열을 여러 번 정렬하는 방식으로 동작한다.

기수 정렬의 주요 아이디어는 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복적으로 정렬하는 것이다. 각 자릿수를 기준으로 정렬할 때는 안정적인 정렬 알고리즘(예: 버블 정렬, 삽입 정렬)을 사용한다.

일반적으로 LSD(Lowest Significant Digit) 방식과 MSD(Most Significant Digit) 방식으로 구현된다. LSD 기수 정렬은 가장 낮은 자릿수부터 시작하여 가장 높은 자릿수까지 순차적으로 정렬하는 방식이며, 숫자의 낮은 자릿수부터 정렬하므로 작은 값부터 큰 값 순으로 정렬된다.

MSD 기수 정렬은 가장 높은 자릿수부터 시작하여 가장 낮은 자릿수까지 역순으로 정렬하는 방식이며, 큰 값부터 작은 값 순으로 정렬된다.

이 방법은 효율적인 특수 정렬 방식으로 시간 복잡도는 N이 걸린다. 하지만 "radixSort(A[ ], n, k)" 형태로 원소들이 각각 최대 k 자리수인 배열을 정렬하기에 k가 logN 사이즈 이상이 되어버리면, NlogN 의 시간 복잡도를 가지는 병합, 퀵 정렬보다 효율적이지 않게된다.

그리고 각각의 자릿수를 맞추기 위해 zero-padding(ex: 493 -> 0493)을 해야하는 번거러움이 있다. 문자열일 경우 zero-padding을 문자열 뒤에다가 해주면 된다.
