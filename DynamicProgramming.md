### 5.1 Dynamic Programming

동적 프로그래밍(Dynamic Programming)은 큰 문제를 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결하는 방법이다. 즉, 큰 문제를 작은 문제로 쪼개고 작은 문제의 답을 저장하여 **재활용**하는 방법이다.

동적 프로그래밍의 대표적인 예제 문제에는 최장 공통 부분 순서(LCS) 알고리즘이 있다. 이 문제는 두 문자열에 대해서 공통적으로 들어있는 부분 순서 중 가장 긴 것을 찾는 문제이다.

---

### 5.2 최장 공통 부분 순서(LCS) 알고리즘

5.1에서도 언급했듯이 이 문제는 두 문자열에 대해서 공통적으로 들어있는 공통 부분순서 중 가장 긴 것을 찾는 문제이다. LCS는 Longest Common Subsequence의 약자이다. 여기서 Subsequence의는 부분 수열을 의미한다. 즉, 문자열이 연속적일 필요 없고 그냥 공통적으로 들어있기만 하면 되는 것이다.

예시를 통해서 쉽게 설명하자면 "ABCDAAWJ" 라는 문자열과 "AQEDACAWF" 라는 문자열이 있다고 가정하자. 이건 문자열이 짧기 때문에 직접 보기만 해도 알 수있다. "ADAAW"가 공통적인 순서로 배치되어 있다. 비록 사이에 다른 알파벳이 끼어 있지만, 그것은 신경쓰지 않아도 된다. 그렇다면 이 문제를 어떻게 동적 프로그래밍을 이용해서 풀어야할까?

재귀함수로 풀 수도 있겠지만, 재귀함수로 풀면 시간복잡도가 매우 커질 것이다. 따라서 2차원 배열과 동적 프로그래밍을 통해 문제를 작게 나누어 값을 재활용하면 된다.

![[LCS.png]](/imgs/LCS.png)

위 예제와 같은 문자열
X = ABCBDAB
Y = BDCABA
가 있다고 가정하자.

위 이차원 배열을 `dp[i][j]`라고 하고, `dp[i][0] = dp[0][j] = 0`으로 초기화 한다.
매칭하려는 문자열이 없다면 중복되는 문자도 없기 때문이다.

`dp[i]`에서 for문을 돌려 `dp[i]`는 고정하고 `d[i][j]` 를 탐색한다. 즉 이중 for문을 통해서 탐색을 실행하면 된다.

`dp[1][j]`에서 문자열이 서로 같다면 그 칸의 대각선 윗칸인 `dp[0][j-1]`에 `+1`을 해준다.(= `dp[i-1][j-1] + 1`)

중복되는 횟수를 문자열의 갯수에 맞게 이차원 배열에 저장하기 때문에 겹치는 항목 중 최신값인 `[i-1][j-1]`에서 값을 갱신시키는 것이다.

탐색을 하다가 만약 같지 않다면 같지 않다면 `max(dp[i-1][j], dp[i][j-1])`의 값을 `dp[i][j]`에 담는다. 중복되는 문자열 중 가장 큰 값을 담아야하기 때문이다. `dp[5][5]`를 보면 알 수 있다. `dp[4][5]`는 BCB 로 3개의 중복을 찾은 상태이다. `dp[5][4]`는 BC로 2개밖에 찾지 못했다. 따라서 더 많이 찾은 최댓값으로 갱신한다.

위 방법대로 하면 다음처럼 숫자가 채워진다 :
![[LCS풀이.png]](/imgs/LCS풀이.png)
